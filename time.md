描述 linux 内核计时器/时间相关概念。
一些疑问：
- linux 内核时间是如何更新的
    若干可编程硬件电路以固定频率振荡产生中断信号，中断处理程序负责更新 linux 内核维护的时间
- linux 定时器实现原理
    linux 内部定时器的数据结构并不是常见的红黑树、堆，而是一种特殊的结构，在不涉及数据迁移的时候，时间复杂度常数时间。具体算法实现可以参考：`linux kernel/timer.c/cascade()`
    > 定时器并没有在终端处理程序中执行，原因是执行定时器任务可能需要比较久的时间。通常由中断处理程序触发软中断，由软中断来完成定时任务。
  
- jiffes、xtime 变量是如何更新的呢？ 通过 atomic?
    该变量是由中断处理程序唯一更新的。其他内核控制路径只会读取该变量的值。但是 xtime 无法通过 atomic 原子更新，似乎只能通过自旋锁。但是终端处理程序是不能被阻塞的，如果使用 try_lock,可能导致这两个变量更新不及时，显然这是不能接受的，因为系统内部很多任务都依赖于这两个变量。那怎么办呢？
    顺序锁闪亮登场！不同于自旋锁、互斥锁等其他锁，在顺序锁中，总能保证写操作及时进行。如果在读操作的时候，发生写操作会出现什么结果呢？**读操作可以检测到写操作，如果检测到写操作，则再次读取**。可以看到为了保证写操作及时进行，将代价转移到了读操作上。

- 为什么 gettimeofdaty() 性能较差(Nginx 内部对 gettimeofdaty()结果进行了缓存，从而避免频繁的系统调用)
    目前 gettimeofday() 是通过 vsyscall 实现的。大概原理是内核与用户共享内存页面，这样用户不用陷入内核，可以直接获取到 xtime 这些变量的值。

