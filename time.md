描述 linux 内核计时器/时间相关概念。
一些疑问：
- linux 内核时间是如何更新的
    若干可编程硬件电路以固定频率振荡产生中断信号，中断处理程序负责更新 linux 内核维护的时间
- linux 定时器实现原理
    linux 内部定时器的数据结构并不是常见的红黑树、堆，而是一种特殊的结构，在不涉及数据迁移的时候，时间复杂度常数时间。具体算法实现可以参考：`linux kernel/timer.c/cascade()`
    > 定时器并没有在终端处理程序中执行，原因是执行定时器任务可能需要比较久的时间。通常由中断处理程序触发软中断，由软中断来完成定时任务。
  
- jiffes、xtime 变量是如何更新的呢？ 通过 atomic?
    该变量是由中断处理程序唯一更新的。其他内核控制路径只会读取该变量的值。但是 xtime 无法通过 atomic 原子更新，似乎只能通过自旋锁。但是终端处理程序是不能被阻塞的，如果使用 try_lock,可能导致这两个变量更新不及时，显然这是不能接受的，因为系统内部很多任务都依赖于这两个变量。那怎么办呢？
    顺序锁闪亮登场！不同于自旋锁、互斥锁等其他锁，在顺序锁中，总能保证写操作及时进行。如果在读操作的时候，发生写操作会出现什么结果呢？**读操作可以检测到写操作，如果检测到写操作，则再次读取**。可以看到为了保证写操作及时进行，将代价转移到了读操作上。

- 为什么 gettimeofdaty() 性能较差(Nginx 内部对 gettimeofdaty()结果进行了缓存，从而避免频繁的系统调用)
    目前 gettimeofday() 是通过 vsyscall 实现的。大概原理是内核与用户共享内存页面，这样用户不用陷入内核，可以直接获取到 xtime 这些变量的值。

# 时间服务器

如果计算机的时间只是由硬件电路中的振荡器决定，因为不同的计算机可能使用不同的振荡器，即使是同一个振荡器，因为高温或者其他原因，也会导致计算机的时间不准。

那么如何解决这个问题呢？详情可以参考: 《鸟哥私房菜服务器假设篇》第 15 章。

两个关键的步骤：
- 使用 `NTP(Network Time Protocol)` 协议与时间服务器进行时间的同步。同步，获取到的就是 timestamp，即自 1970-01-01 以来的秒数。

- 根据主机的时区配置，展示不同的时间。

    这里我们以 Unbuntu 系统为例介绍下如何配置时区。

    三个关键的配置文件：
    - /usr/share/zoneinfo/

        存储了各个时区的信息。

    - /etc/timezone

        通过指定 /usr/share/zoneinfo/ 下文件路径的方式，来指定时区信息。比如: `Asia/Shanghai` 或者 `Amercia/New_York`

    - /etc/localtime

         指向 /usr/share/zoneinfo/ 下由 /etc/timezone 指定的文件的软连接


我们说到时间，有两种时间，一种是硬件时间，也就是硬件电路维护的时间，另一个就是软件时间，就是上面同步到的时间。

实际上，在计算机开机的时候，就是使用硬件时间作为系统时间。如果硬件时间跟软件时间相差比较大，就需要通过软件时间来更新硬件时间，命令是:
- `hwclock -r` 读取硬件时间
- `hwclock -w` 使用软件时间更新硬件时间

> 以上 操作需要超级账号权限

